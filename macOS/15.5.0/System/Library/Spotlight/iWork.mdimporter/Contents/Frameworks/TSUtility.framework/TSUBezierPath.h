@class NSArray, NSString;

@interface TSUBezierPath : NSObject <NSCopying> {
    long long sfr_elementCount;
    long long sfr_elementMax;
    struct PATHSEGMENT { unsigned char x0 : 4; unsigned long x1 : 60; struct CGPoint { double x0; double x1; } x2; } *sfr_head;
    double *sfr_elementLength;
    double sfr_totalLength;
    long long sfr_lastSubpathIndex;
    void *sfr_extraSegments;
    double sfr_lineWidth;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } sfr_bounds;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } sfr_controlPointBounds;
    double sfr_miterLimit;
    double sfr_flatness;
    double *sfr_dashedLinePattern;
    unsigned long long sfr_dashedLineCount;
    double sfr_dashedLinePhase;
    struct CGPath { } *sfr_path;
    long long sfr_extraSegmentCount;
    long long sfr_extraSegmentMax;
    struct { unsigned char sfr_flags : 8; unsigned char sfr_pathState : 2; unsigned char sfr_calculatedLengths : 1; unsigned int sfr_unused : 21; } sfr_bpFlags;
}

@property (readonly, nonatomic) BOOL isCompound;
@property (readonly, nonatomic) BOOL isOpen;
@property (readonly, nonatomic) BOOL isFinite;
@property (readonly, nonatomic) BOOL isLineSegment;
@property (readonly, nonatomic) BOOL isEffectivelyClosed;
@property (readonly, nonatomic) BOOL containsElementsOtherThanMoveAndClose;
@property (readonly, nonatomic) unsigned long long totalSubpathCountIncludingEffectivelyEmptySubpaths;
@property (readonly, nonatomic) NSArray *visuallyDistinctSubregions;
@property (readonly, nonatomic) BOOL hasAtLeastTwoVisuallyDistinctSubregions;
@property (readonly, nonatomic) double flattenedArea;
@property (readonly, nonatomic) NSString *inferredAccessibilityDescription;
@property (nonatomic) double lineWidth;
@property (nonatomic) unsigned long long lineCapStyle;
@property (nonatomic) unsigned long long lineJoinStyle;
@property (nonatomic) long long windingRule;
@property (nonatomic) double miterLimit;
@property (nonatomic) double flatness;
@property (readonly, nonatomic) struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } bounds;
@property (readonly, nonatomic) BOOL containsClosePathElement;

+ (id)exteriorOfBezierPath:(id)a0;
+ (id)uniteBezierPaths:(id)a0;
+ (struct Path { int x0; int x1; int x2; struct path_descr *x3; int x4; int x5; BOOL x6; BOOL x7; int x8; int x9; int x10; char *x11; } *)p_bezierToPath:(id)a0;
+ (id)p_pathToBezier:(struct Path { int x0; int x1; int x2; struct path_descr *x3; int x4; int x5; BOOL x6; BOOL x7; int x8; int x9; int x10; char *x11; } *)a0;
+ (id)smoothBezierPath:(id)a0 withThreshold:(double)a1;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })p_pathToBounds:(struct Path { int x0; int x1; int x2; struct path_descr *x3; int x4; int x5; BOOL x6; BOOL x7; int x8; int x9; int x10; char *x11; } *)a0;
+ (id)appendBezierPaths:(id)a0;
+ (id)bezierPathWithConvexHullOfPoints:(struct CGPoint { double x0; double x1; } *)a0 count:(unsigned long long)a1;
+ (id)excludeBezierPaths:(id)a0;
+ (id)intersectBezierPaths:(id)a0;
+ (id)outsideEdgeOfBezierPath:(id)a0;
+ (id)subtractBezierPaths:(id)a0;
+ (id)tracedPathForImage:(struct CGImage { } *)a0 alphaThreshold:(double)a1 pointSpacing:(double)a2;
+ (id)createClippedPath:(id)a0 headPositioning:(struct { double x0; struct CGPoint { double x0; double x1; } x1; long long x2; double x3; })a1 tailPositioning:(struct { double x0; struct CGPoint { double x0; double x1; } x1; long long x2; double x3; })a2 stroke:(id)a3;
+ (struct { double x0; struct CGPoint { double x0; double x1; } x1; long long x2; double x3; })lineEndPositioningOnPath:(id)a0 atHead:(BOOL)a1 headPoint:(struct CGPoint { double x0; double x1; })a2 tailPoint:(struct CGPoint { double x0; double x1; })a3 headLineEnd:(id)a4 tailLineEnd:(id)a5 stroke:(id)a6;
+ (id)p_subtractBezierPaths:(id)a0 usingGPC:(BOOL)a1;
+ (struct { double x0; struct CGPoint { double x0; double x1; } x1; long long x2; double x3; })makeDefaultPositioning;
+ (BOOL)p_allPathsAreFlat:(id)a0;
+ (struct CGPoint { double x0; double x1; })p_findPointWithGreatestSlopeFromStartPoint:(struct CGPoint { double x0; double x1; })a0 toPointA:(struct CGPoint { double x0; double x1; })a1 orPointB:(struct CGPoint { double x0; double x1; })a2;
+ (id)p_intersectBezierPaths:(id)a0 usingGPC:(BOOL)a1;
+ (id)p_mergeIntersectingSubpaths:(id)a0 stopAfterFoundTwo:(BOOL)a1;
+ (id)p_normalizeSubpaths:(id)a0;
+ (id)p_uniteBezierPaths:(id)a0 usingGPC:(BOOL)a1;
+ (id)p_usingGPCBooleanBezierPaths:(id)a0 operation:(int)a1;
+ (id)p_usingLivarotBooleanBezierPaths:(id)a0 operation:(int)a1;
+ (id)p_usingLivarotStrokeBezierPath:(id)a0 withThreshold:(double)a1;
+ (id)subtractPolygonalBezierPaths:(id)a0;
+ (id)unitePolygonalBezierPaths:(id)a0;
+ (void)initialize;
+ (double)lineWidth;
+ (void)setLineWidth:(double)a0;
+ (double)defaultFlatness;
+ (void)setWindingRule:(long long)a0;
+ (id)bezierPath;
+ (id)bezierPathWithCGPath:(struct CGPath { } *)a0;
+ (id)bezierPathWithOvalInRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (id)bezierPathWithRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (void)clipRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (unsigned long long)defaultLineCapStyle;
+ (unsigned long long)defaultLineJoinStyle;
+ (double)defaultLineWidth;
+ (double)defaultMiterLimit;
+ (long long)defaultWindingRule;
+ (void)fillRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (double)flatness;
+ (unsigned long long)lineCapStyle;
+ (unsigned long long)lineJoinStyle;
+ (double)miterLimit;
+ (void)setDefaultFlatness:(double)a0;
+ (void)setDefaultLineCapStyle:(unsigned long long)a0;
+ (void)setDefaultLineJoinStyle:(unsigned long long)a0;
+ (void)setDefaultLineWidth:(double)a0;
+ (void)setDefaultMiterLimit:(double)a0;
+ (void)setDefaultWindingRule:(long long)a0;
+ (void)setFlatness:(double)a0;
+ (void)setLineCapStyle:(unsigned long long)a0;
+ (void)setLineJoinStyle:(unsigned long long)a0;
+ (void)setMiterLimit:(double)a0;
+ (void)strokeLineFromPoint:(struct CGPoint { double x0; double x1; })a0 toPoint:(struct CGPoint { double x0; double x1; })a1;
+ (void)strokeRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (long long)windingRule;
+ (id)bezierPathWithStart:(struct CGPoint { double x0; double x1; })a0 end:(struct CGPoint { double x0; double x1; })a1;
+ (id)bezierPathWithLegacyRoundedRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 cornerRadius:(double)a1;
+ (id)bezierPathWithRoundedRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 upperRightRadius:(double)a1 lowerRightRadius:(double)a2 lowerLeftRadius:(double)a3 upperLeftRadius:(double)a4 useLegacyCorners:(BOOL)a5 keepNoOpElements:(BOOL)a6;
+ (id)bezierPathWithDefaultsForErrorCases;
+ (id)bezierPathWithContinuousCornerRoundedRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 cornerRadius:(double)a1;
+ (double)minimumLengthForSideToHaveFullContinuityWithCornerRadius1:(double)a0 cornerRadius2:(double)a1;

- (struct CGPoint { double x0; double x1; })pointAt:(double)a0;
- (id)initWithArchive:(const void *)a0;
- (id)intersectBezierPath:(id)a0;
- (id)subtractBezierPath:(id)a0;
- (id)uniteWithBezierPath:(id)a0;
- (void)saveToArchive:(void *)a0;
- (void)addIntersectionsWithLine:(struct CGPoint { double x0; double x1; }[2])a0 to:(id)a1;
- (void)addIntersectionsWithPath:(id)a0 to:(id)a1;
- (void)addIntersectionsWithPath:(id)a0 to:(id)a1 allIntersections:(BOOL)a2 reversed:(BOOL)a3;
- (void)appendBezierPath:(id)a0 fromSegment:(long long)a1 t:(double)a2 toSegment:(long long)a3 t:(double)a4 withoutMove:(BOOL)a5;
- (void)appendBezierPath:(id)a0 fromSegment:(long long)a1 toSegment:(long long)a2;
- (id)chisel;
- (id)copyFromSegment:(int)a0 t:(double)a1 toSegment:(int)a2 t:(double)a3;
- (double)curvatureAt:(double)a0;
- (double)curvatureAt:(double)a0 fromElement:(long long)a1;
- (long long)elementPercentage:(double *)a0 forOverallPercentage:(double)a1;
- (double)elementPercentageFromElement:(long long)a0 forOverallPercentage:(double)a1;
- (void)getStartPoint:(struct CGPoint { double x0; double x1; } *)a0 andEndPoint:(struct CGPoint { double x0; double x1; } *)a1;
- (struct CGPoint { double x0; double x1; })gradientAt:(double)a0;
- (struct CGPoint { double x0; double x1; })gradientAt:(double)a0 fromElement:(long long)a1;
- (struct CGPoint { double x0; double x1; })myGradientAt:(double)a0;
- (struct CGPoint { double x0; double x1; })myGradientAt:(double)a0 fromElement:(long long)a1;
- (struct CGPoint { double x0; double x1; })nearestAngleOnPathToLine:(struct CGPoint { double x0; double x1; }[2])a0;
- (struct CGPoint { double x0; double x1; })nearestPointOnPathToLine:(struct CGPoint { double x0; double x1; }[2])a0;
- (struct CGPoint { double x0; double x1; })pointAt:(double)a0 fromElement:(long long)a1;
- (struct CGPoint { double x0; double x1; })rawGradientAt:(double)a0 fromElement:(long long)a1;
- (void)recursiveSubdivideOntoPath:(id)a0 into:(id)a1;
- (void)recursiveSubdivideOntoPath:(id)a0 withScaling:(struct { double x0; double x1; })a1 inElementRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a2 into:(id)a3;
- (void)recursiveSubdivideOntoPath:(id)a0 withScaling:(struct { double x0; double x1; })a1 into:(id)a2;
- (void)addPathToContext:(struct CGContext { } *)a0;
- (id)aliasedPathInContext:(struct CGContext { } *)a0 effectiveStrokeWidth:(float)a1;
- (id)aliasedPathWithViewScale:(float)a0 effectiveStrokeWidth:(float)a1;
- (void)alignBoundsToOrigin;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })boundsIncludingStroke;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })boundsIncludingStrokeWidth:(double)a0 joinStyle:(unsigned long long)a1 capStyle:(unsigned long long)a2 miterLimit:(double)a3 needsToExtendJoins:(BOOL)a4;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })boundsIncludingTSDStroke:(id)a0;
- (void)clearStroke:(struct CGContext { } *)a0;
- (id)copyWithPointsInRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a0;
- (long long)elementPercentage:(double *)a0 forOverallPercentage:(double)a1 startingElementIndex:(long long)a2 lengthToStartingElement:(double)a3;
- (BOOL)intersectsRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 hasFill:(BOOL)a1;
- (id)p_aliasedPathInContext:(struct CGContext { } *)a0 viewScale:(float)a1 effectiveStrokeWidth:(float)a2;
- (id)p_copyWithPointsInRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a0 countingSubpaths:(unsigned long long *)a1;
- (id)p_elementCountForSubpaths;
- (id)pathByWobblingByUpTo:(double)a0 subdivisions:(unsigned long long)a1;
- (id)pathSplitAtSubpathBoundariesWithSoftElementLimit:(unsigned long long)a0 hardElementLimit:(unsigned long long)a1;
- (struct CGPoint { double x0; double x1; })pointAlongPathAtPercentage:(double)a0;
- (struct CGPoint { double x0; double x1; })roundPoint:(struct CGPoint { double x0; double x1; })a0 inContext:(struct CGContext { } *)a1 strokeWidth:(int)a2;
- (void)takeAttributesFromStroke:(id)a0;
- (double)yValueFromXValue:(double)a0;
- (double)yValueFromXValue:(double)a0 elementIndex:(long long *)a1 parametricValue:(double *)a2;
- (id)arrayOfSubpathsWithEffectivelyEmptySubpathsRemoved:(BOOL)a0;
- (double)distanceToPoint:(struct CGPoint { double x0; double x1; })a0 elementIndex:(unsigned long long *)a1 tValue:(double *)a2 threshold:(double)a3 findClosestMatch:(BOOL)a4;
- (id)bezierPathByOffsettingPath:(double)a0 joinStyle:(unsigned long long)a1 attemptingUsingLivarotFirstWithThresholds:(id)a2;
- (id)strokedCopyAttemptingUsingLivarotFirst;
- (void)appendPointsInRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a0 fromBezierPath:(id)a1;
- (id)bezierPathByOffsettingPath:(double)a0 joinStyle:(unsigned long long)a1;
- (void)iterateOverPathWithPointDistancePerIteration:(double)a0 usingBlock:(id /* block */)a1;
- (id)labelForSize:(struct CGSize { double x0; double x1; })a0;
- (id)p_bezierPathByOffsettingPath:(double)a0 joinStyle:(unsigned long long)a1 attemptWithLivarotFirst:(BOOL)a2 livarotOverrideThresholds:(id)a3;
- (BOOL)p_equalWidthAndHeightForSize:(struct CGSize { double x0; double x1; })a0;
- (id)p_pathBySplittingAtPointGuaranteedToBeOnPath:(struct CGPoint { double x0; double x1; })a0 controlPointDistanceEqual:(BOOL)a1 elementIndex:(long long)a2 parametricValue:(double)a3;
- (id)p_strokedCopyAttemptingUsingLivarotFirst:(BOOL)a0 livarotOverrideThresholds:(id)a1;
- (id)p_strokedPathByUsingCG;
- (id)pathByCreatingHoleInPathAtPoint:(struct CGPoint { double x0; double x1; })a0 withDiameter:(id /* block */)a1 andThreshold:(double)a2 updatingPatternOffsetsBySubpath:(id)a3;
- (id)pathByNormalizingClosedPathToRemoveSelfIntersections;
- (id)pathBySplittingAtPointOnPath:(struct CGPoint { double x0; double x1; })a0 controlPointDistanceEqual:(BOOL)a1;
- (struct CGPoint { double x0; double x1; })pointAlongPathAtPercentage:(double)a0 withFlattenedPath:(id)a1 andLength:(double *)a2 atStartIndex:(unsigned long long *)a3;
- (void)roundCoordinates:(double)a0;
- (id)strokedCopy;
- (id)subtractPolygonalBezierPath:(id)a0;
- (struct CGPoint { double x0; double x1; })transformedTotalCoordinate:(struct CGPoint { double x0; double x1; })a0 betweenElement:(long long)a1 andElement:(long long)a2 getElement:(long long *)a3 getPercentage:(double *)a4;
- (id)uniteWithPolygonalBezierPath:(id)a0;
- (void)dealloc;
- (id)copyWithZone:(struct _NSZone { } *)a0;
- (id)description;
- (unsigned long long)hash;
- (id)init;
- (BOOL)isEqual:(id)a0;
- (double)length;
- (const char *)cString;
- (BOOL)isEmpty;
- (id)initWithCString:(const char *)a0;
- (struct CGPath { } *)CGPath;
- (void)appendBezierPathWithOvalInRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (void)removeAllPoints;
- (void)addClip;
- (long long)elementAtIndex:(long long)a0;
- (void)_appendArcSegmentWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 angle1:(double)a2 angle2:(double)a3;
- (id)_copyFlattenedPath;
- (void)_deviceClosePath;
- (void)_deviceCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (void)_deviceLineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)_deviceMoveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)appendBezierPath:(id)a0;
- (void)appendBezierPathWithArcFromPoint:(struct CGPoint { double x0; double x1; })a0 toPoint:(struct CGPoint { double x0; double x1; })a1 radius:(double)a2;
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 startAngle:(double)a2 endAngle:(double)a3;
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 startAngle:(double)a2 endAngle:(double)a3 clockwise:(BOOL)a4;
- (void)appendBezierPathWithPoints:(struct CGPoint { double x0; double x1; } *)a0 count:(long long)a1;
- (void)appendBezierPathWithRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (id)bezierPathByFlatteningPath;
- (id)bezierPathByReversingPath;
- (void)closePath;
- (BOOL)containsPoint:(struct CGPoint { double x0; double x1; })a0;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })controlPointBounds;
- (struct CGPoint { double x0; double x1; })currentPoint;
- (void)curveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (void)curveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint:(struct CGPoint { double x0; double x1; })a1;
- (long long)elementAtIndex:(long long)a0 associatedPoints:(struct CGPoint { double x0; double x1; } *)a1;
- (long long)elementCount;
- (void)fill;
- (void)flattenIntoPath:(id)a0;
- (void)getLineDash:(double *)a0 count:(long long *)a1 phase:(double *)a2;
- (BOOL)isRectangular;
- (void)lineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)moveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)relativeCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (void)relativeCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint:(struct CGPoint { double x0; double x1; })a1;
- (void)relativeLineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)relativeMoveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)setAssociatedPoints:(struct CGPoint { double x0; double x1; } *)a0 atIndex:(long long)a1;
- (void)setLineDash:(const double *)a0 count:(long long)a1 phase:(double)a2;
- (void)stroke;
- (void)transformUsingAffineTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0;
- (BOOL)_isValid:(double)a0;
- (void)_doPath;
- (void)_addPathSegment:(long long)a0 point:(struct CGPoint { double x0; double x1; })a1;
- (void)_appendToPath:(id)a0 skippingInitialMoveIfPossible:(BOOL)a1;
- (struct CGPoint { double x0; double x1; })_checkPointForValidity:(struct CGPoint { double x0; double x1; })a0;
- (void)appendBezierPath:(id)a0 skippingInitialMoveIfPossible:(BOOL)a1;
- (void)appendBezierPathWithArcWithEllipseBounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 startAngle:(double)a1 swingAngle:(double)a2 angleType:(int)a3 startNewPath:(BOOL)a4;
- (void)appendBezierPathWithArcWithEllipseBounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 startRadialVector:(struct CGPoint { double x0; double x1; })a1 endRadialVector:(struct CGPoint { double x0; double x1; })a2 angleSign:(int)a3 startNewPath:(BOOL)a4;
- (id)bezierPathByFlatteningPathWithFlatness:(double)a0;
- (id)bezierPathByRemovingRedundantElements;
- (id)bezierPathByRemovingSmallSubpathsForInteriorWrapsForInset:(double)a0;
- (double)calculateLengthOfElement:(long long)a0;
- (void)calculateLengths;
- (void)copyPathAttributesTo:(id)a0;
- (long long)elementAtIndex:(long long)a0 allPoints:(struct CGPoint { double x0; double x1; } *)a1;
- (void)flattenIntoPath:(id)a0 flatness:(double)a1;
- (BOOL)isCircular;
- (BOOL)isClockwise;
- (BOOL)isDiamond;
- (BOOL)isFlat;
- (BOOL)isTriangular;
- (double)lengthOfElement:(long long)a0;
- (double)lengthToElement:(long long)a0;
- (id)p_bezierPathByRemovingRedundantElementAndSubregionsSmallerThanThreshold:(double)a0;
- (void)subdivideBezierWithFlatness:(double)a0 startPoint:(struct CGPoint { double x0; double x1; })a1 controlPoint1:(struct CGPoint { double x0; double x1; })a2 controlPoint2:(struct CGPoint { double x0; double x1; })a3 endPoint:(struct CGPoint { double x0; double x1; })a4;
- (void)convertCloseElementsToLineElements;

@end
